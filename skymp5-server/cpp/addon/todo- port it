JsValue GetJsObjectFromPapyrusObject(
  const VarValue& value, const std::vector<std::string>& espmFilenames)
{
  auto ptr = static_cast<IGameObject*>(value);
  if (!ptr) {
    return JsValue::Null();
  }

  if (auto concrete = dynamic_cast<EspmGameObject*>(ptr)) {
    auto rawId = concrete->record.rec->GetId();
    auto id = concrete->record.ToGlobalId(rawId);

    auto desc = FormDesc::FromFormId(id, espmFilenames).ToString();

    auto result = JsValue::Object();
    result.SetProperty("type", JsValue("espm"));
    result.SetProperty("desc", JsValue(desc));
    return result;
  }

  if (auto concrete = dynamic_cast<MpFormGameObject*>(ptr)) {
    auto formId =
      concrete->GetFormPtr() ? concrete->GetFormPtr()->GetFormId() : 0;

    auto desc = FormDesc::FromFormId(formId, espmFilenames).ToString();

    auto result = JsValue::Object();
    result.SetProperty("type", JsValue("form"));
    result.SetProperty("desc", JsValue(desc));
    return result;
  }

  throw std::runtime_error("This type of IGameObject is not supported in JS");
}

JsValue GetJsValueFromPapyrusValue(
  const VarValue& value, const std::vector<std::string>& espmFilenames)
{
  if (value.promise) {
    auto promiseCallback = JsValue::Function(
      [value, espmFilenames](const JsFunctionArguments& args) {
        auto& resolve = args[1];

        value.promise->Then([resolve, espmFilenames](const VarValue& v) {
          resolve.Call({ JsValue::Undefined(),
                         GetJsValueFromPapyrusValue(v, espmFilenames) });
        });

        // TODO: catch/reject?

        return JsValue::Undefined();
      });
  }
  switch (value.GetType()) {
    case VarValue::kType_Object:
      return GetJsObjectFromPapyrusObject(value, espmFilenames);
    case VarValue::kType_Identifier:
      throw std::runtime_error(
        "Unexpected convertion from Papyrus identifier");
    case VarValue::kType_String: {
      std::string str = static_cast<const char*>(value);
      return JsValue::String(str);
    }
    case VarValue::kType_Integer: {
      auto v = static_cast<int32_t>(value);
      return JsValue::Int(v);
    }
    case VarValue::kType_Float: {
      auto v = static_cast<double>(value);
      return JsValue::Double(v);
    }
    case VarValue::kType_Bool: {
      auto v = static_cast<bool>(value);
      return JsValue::Bool(v);
    }

    case VarValue::kType_ObjectArray:
    case VarValue::kType_StringArray:
    case VarValue::kType_IntArray:
    case VarValue::kType_FloatArray:
    case VarValue::kType_BoolArray: {
      if (value.pArray == nullptr)
        return JsValue::Null();
      auto arr = JsValue::Array(value.pArray->size());
      int n = static_cast<int>(arr.GetProperty("length"));
      for (int i = 0; i < n; ++i) {
        arr.SetProperty(
          i, GetJsValueFromPapyrusValue(value.pArray->at(i), espmFilenames));
      }
      return arr;
    }
  }
  std::stringstream ss;
  ss << "Could not convert a Papyrus value " << value << " to JS format";
  throw std::runtime_error(ss.str());
}

VarValue GetPapyrusValueFromJsValue(const JsValue& v, bool treatNumberAsInt,
                                    WorldState& wst)
{
  switch (v.GetType()) {
    case JsValue::Type::Boolean:
      if (std::string(v.ToString())[0] == 't') {
        return VarValue(true);
      }
      return VarValue(false);
    case JsValue::Type::Null:
      return VarValue::None();
    // undefined is not a valid value in Papyrus
    // But TypeScript should be able to return void, so:
    case JsValue::Type::Undefined: {
      return VarValue::None();
    }
    case JsValue::Type::Number: {
      double number = static_cast<double>(v);
      return treatNumberAsInt ? VarValue(static_cast<int32_t>(number))
                              : VarValue(number);
    }
    case JsValue::Type::String: {
      auto str = static_cast<std::string>(v);
      VarValue res(str);
      return res;
    }
    case JsValue::Type::Array: {
      auto arr = v;
      if (arr.GetProperty("length").ToString() == "0") {
        // Treat zero-length arrays as kType_ObjectArray ("none array")
        VarValue papyrusArray(VarValue::kType_ObjectArray);
        papyrusArray.pArray.reset(new std::vector<VarValue>);
        return papyrusArray;
      }

      auto arrayContents = std::make_shared<std::vector<VarValue>>();
      uint8_t type = ~0;

      int n = static_cast<int>(arr.GetProperty("length"));
      for (int i = 0; i < n; ++i) {
        arrayContents->push_back(GetPapyrusValueFromJsValue(
          arr.GetProperty(i), treatNumberAsInt, wst));

        auto extractedType = arrayContents->back().GetType();
        if (type == static_cast<uint8_t>(~0)) {
          type = extractedType;
        } else if (extractedType != type) {
          throw std::runtime_error(
            "Papyrus doesn't support heterogeneous arrays");
        }
      }

      VarValue papyrusArray(
        ActivePexInstance::GetArrayTypeByElementType(type));
      papyrusArray.pArray = arrayContents;

      return papyrusArray;
    }
    case JsValue::Type::Object: {
      bool isPromise =
        v.GetProperty("then").GetType() == JsValue::Type::Function;
      if (isPromise) {
        VarValue res = VarValue::None();
        res.promise = std::make_shared<Viet::Promise<VarValue>>();

        auto then = v.GetProperty("then");

        auto wst_ = &wst;
        then.Call(
          { v, JsValue::Function([res, wst_](const JsFunctionArguments& args) {
              bool treatNumberAsInt = false;
              res.promise->Resolve(
                GetPapyrusValueFromJsValue(args[1], treatNumberAsInt, *wst_));
              return JsValue::Undefined();
            }) });
        // TODO: catch/reject?

        return res;
      }

      auto desc = static_cast<std::string>(v.GetProperty("desc"));
      auto type = static_cast<std::string>(v.GetProperty("type"));

      const auto espmFileNames = wst.GetEspm().GetFileNames();
      uint32_t id = FormDesc::FromString(desc).ToFormId(espmFileNames);

      if (type == "form") {
        MpObjectReference& refr = wst.GetFormAt<MpObjectReference>(id);
        return VarValue(std::make_shared<MpFormGameObject>(&refr));
      }

      if (type == "espm") {
        auto lookupRes = wst.GetEspm().GetBrowser().LookupById(id);
        if (!lookupRes.rec) {
          std::stringstream ss;
          ss << "ESPM record with id " << std::hex << id << " doesn't exist";
          throw std::runtime_error(ss.str());
        }
        return VarValue(std::make_shared<EspmGameObject>(lookupRes));
      }

      std::stringstream ss;
      ss << "Unknown object type '" << type << "', must be 'form' | 'espm'";
      throw std::runtime_error(ss.str());
    }
    default:
      break;
  }
  std::stringstream ss;
  ss << "JS type " << static_cast<int>(v.GetType())
     << " is not castable to any of Papyrus types";
  throw std::runtime_error(ss.str());
}

mp.SetProperty(
    "place",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto globalRecordId = ExtractFormId(args[1], "globalRecordId");
      auto akFormToPlace =
        partOne->GetEspm().GetBrowser().LookupById(globalRecordId);
      if (!akFormToPlace.rec) {
        std::stringstream ss;
        ss << std::hex << "Bad record Id " << globalRecordId;
        throw std::runtime_error(ss.str());
      }

      std::string type = akFormToPlace.rec->GetType().ToString();

      LocationalData locationalData = { { 0, 0, 0 },
                                        { 0, 0, 0 },
                                        FormDesc::Tamriel() };
      FormCallbacks callbacks = partOne->CreateFormCallbacks();

      std::unique_ptr<MpObjectReference> newRefr;
      if (akFormToPlace.rec->GetType() == "NPC_") {
        auto actor = new MpActor(locationalData, callbacks, globalRecordId);
        newRefr.reset(actor);
      } else {
        newRefr.reset(new MpObjectReference(locationalData, callbacks,
                                            globalRecordId, type));
      }

      auto worldState = &partOne->worldState;
      auto newRefrId = worldState->GenerateFormId();
      worldState->AddForm(std::move(newRefr), newRefrId);

      auto& refr = worldState->GetFormAt<MpObjectReference>(newRefrId);
      refr.ForceSubscriptionsUpdate();

      return JsValue(static_cast<double>(refr.GetFormId()));
    }));

  mp.SetProperty(
    "lookupEspmRecordById",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto globalRecordId = ExtractFormId(args[1], "globalRecordId");

      auto espmLookupResult = JsValue::Object();

      auto lookupRes =
        partOne->GetEspm().GetBrowser().LookupById(globalRecordId);
      if (lookupRes.rec) {
        auto fields = JsValue::Array(0);

        auto& cache = partOne->worldState.GetEspmCache();

        espm::IterateFields_(
          lookupRes.rec,
          [&](const char* type, uint32_t size, const char* data) {
            auto uint8arr = JsValue::Uint8Array(size);
            memcpy(uint8arr.GetTypedArrayData(), data, size);

            auto push = fields.GetProperty("push");
            auto field = JsValue::Object();
            field.SetProperty("type", JsValue(std::string(type, 4)));
            field.SetProperty("data", uint8arr);
            push.Call({ fields, field });
          },
          cache);

        auto id = JsValue(static_cast<double>(lookupRes.rec->GetId()));
        auto edid = JsValue(lookupRes.rec->GetEditorId(cache));
        auto type = JsValue(lookupRes.rec->GetType().ToString());
        auto flags = JsValue(static_cast<double>(lookupRes.rec->GetFlags()));

        auto record = JsValue::Object();
        record.SetProperty("id", id);
        record.SetProperty("editorId", edid);
        record.SetProperty("type", type);
        record.SetProperty("flags", flags);
        record.SetProperty("fields", fields);
        espmLookupResult.SetProperty("record", record);

        espmLookupResult.SetProperty(
          "fileIndex", JsValue(static_cast<int>(lookupRes.fileIdx)));
      }

      return espmLookupResult;
    }));

  mp.SetProperty(
    "getEspmLoadOrder",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto fileNames = partOne->GetEspm().GetFileNames();
      auto arr = JsValue::Array(fileNames.size());
      for (int i = 0; i < static_cast<int>(fileNames.size()); ++i) {
        arr.SetProperty(JsValue(i), JsValue(fileNames[i]));
      }
      return arr;
    }));

  mp.SetProperty(
    "getDescFromId",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto formId = ExtractFormId(args[1]);
      auto espmFileNames = partOne->GetEspm().GetFileNames();
      auto formDesc = FormDesc::FromFormId(formId, espmFileNames);

      return JsValue(formDesc.ToString());
    }));

  mp.SetProperty(
    "getIdFromDesc",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto str = ExtractString(args[1], "formDesc");
      auto espmFileNames = partOne->GetEspm().GetFileNames();
      auto formDesc = FormDesc::FromString(str);

      return JsValue(static_cast<double>(formDesc.ToFormId(espmFileNames)));
    }));

  mp.SetProperty(
    "callPapyrusFunction",
    JsValue::Function([this, update](const JsFunctionArguments& chakraArgs) {
      auto callType = ExtractString(chakraArgs[1], "callType");
      auto className = ExtractString(chakraArgs[2], "className");
      auto functionName = ExtractString(chakraArgs[3], "functionName");
      auto self =
        GetPapyrusValueFromJsValue(chakraArgs[4], false, partOne->worldState);

      auto arr = chakraArgs[5];
      auto arrSize = static_cast<int>(arr.GetProperty("length"));

      bool treatNumberAsInt = false; // TODO?

      std::vector<VarValue> args;
      args.resize(arrSize);
      for (int i = 0; i < arrSize; ++i) {
        args[i] = GetPapyrusValueFromJsValue(
          arr.GetProperty(JsValue(i)), treatNumberAsInt, partOne->worldState);
      }

      VarValue res;

      auto& vm = partOne->worldState.GetPapyrusVm();
      if (callType == "method") {
        res = vm.CallMethod(static_cast<IGameObject*>(self),
                            functionName.data(), args);
      } else if (callType == "global") {
        res = vm.CallStatic(className, functionName, args);
      } else {

        throw std::runtime_error("Unknown callType " + callType);
      }

      return GetJsValueFromPapyrusValue(res, partOne->worldState.espmFiles);
    }));

  mp.SetProperty(
    "registerPapyrusFunction",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto callType = ExtractString(args[1], "callType");
      auto className = ExtractString(args[2], "className");
      auto functionName = ExtractString(args[3], "functionName");
      auto& f = ExtractFunction(args[4], "f");

      auto& vm = partOne->worldState.GetPapyrusVm();

      auto* wst = &partOne->worldState;

      FunctionType fType;

      if (callType == "method") {
        fType = FunctionType::Method;
      } else if (callType == "global") {
        fType = FunctionType::GlobalFunction;
      } else {

        throw std::runtime_error("Unknown callType " + callType);
      }

      vm.RegisterFunction(
        className, functionName, fType,
        [f, wst](const VarValue& self, const std::vector<VarValue>& args) {
          JsValue jsSelf = GetJsValueFromPapyrusValue(self, wst->espmFiles);

          auto jsArgs = JsValue::Array(static_cast<uint32_t>(args.size()));
          for (int i = 0; i < static_cast<int>(args.size()); ++i) {
            jsArgs.SetProperty(
              i, GetJsValueFromPapyrusValue(args[i], wst->espmFiles));
          }

          auto jsResult = f.Call({ JsValue::Undefined(), jsSelf, jsArgs });

          bool treatResultAsInt = false; // TODO?

          return GetPapyrusValueFromJsValue(jsResult, treatResultAsInt, *wst);
        });

      return JsValue::Undefined();
    }));

  mp.SetProperty(
    "sendCustomPacket",
    JsValue::Function([this, update](const JsFunctionArguments& args) {
      auto formId = ExtractFormId(args[1]);
      std::string packet = ExtractNewValueStr(args[2]);
      auto userId = partOne->GetUserByActor(formId);
      partOne->SendCustomPacket(userId, packet);
      return JsValue::Undefined();
    }));