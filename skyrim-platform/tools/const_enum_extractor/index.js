const fs = require("fs");
const path = require("path");
const ts = require("typescript");

function extractConstEnums(sourceCode) {
    const sourceFile = ts.createSourceFile(
        "temp.ts",
        sourceCode,
        ts.ScriptTarget.ES2015,
        true
    );

    const constEnums = [];

    function visit(node) {
        if (ts.isEnumDeclaration(node) && node.modifiers?.some(modifier => modifier.kind === ts.SyntaxKind.ConstKeyword)) {
            const enumName = node.name.text;
            const values = {};
            let lastValue = -1; // Assume starting value is -1 so the first auto value will be 0 if not specified

            node.members.forEach(member => {
                const key = member.name.getText(sourceFile);
                if (member.initializer) {
                    if (ts.isNumericLiteral(member.initializer)) {
                        lastValue = parseInt(member.initializer.text, 10);
                    } else {
                        // Handle non-numeric initializers differently if necessary
                        lastValue = member.initializer.text; // This simplistic approach assumes all initializers are numeric
                    }
                    values[key] = lastValue;
                } else {
                    // If no initializer is present, increment the last value
                    values[key] = ++lastValue;
                }
            });

            constEnums.push({ name: enumName, values });
        }

        ts.forEachChild(node, visit);
    }

    visit(sourceFile);

    return constEnums;
}

const skyrimPlatformTsPath = "../../../skyrim-platform/src/platform_se/codegen/convert-files/skyrimPlatform.ts";
const constEnumApiCppPath = "../../../skyrim-platform/src/platform_se/skyrim_platform/ConstEnumApi.cpp";

const tsCode = fs.readFileSync(skyrimPlatformTsPath, "utf8");

const generatedBy = path.relative("../../..", __dirname).replaceAll("\\", "/");
const comment = `// This file is generated by ${generatedBy}\n\n`;

const prefix = "#include \"ConstEnumApi.h\"\n\nauto _n_ = [](auto env, const auto& v) { return Napi::Number::New(env, v); };\nauto _s_ = [](auto env, const auto& v) { return Napi::String::New(env, v); };\nauto _u_ = [](auto i) { return static_cast<uint32_t>(i); };\n\nvoid ConstEnumApi::Register(Napi::Env env, Napi::Object& exports,\n                            std::shared_ptr<JsEngine> jsEngine)\n{\n";

const stringify = (value) => {
    return JSON.stringify(value);
};

const prepareKey = (value) => {
    if (typeof value === "number") {
        return `_u_(${stringify(value)})`;
    }
    return stringify(value);
};

const prepareValue = (value) => {
    if (typeof value === "number") {
        return `_n_(env, ${stringify(value)})`;
    }
    else if (typeof value === "string") {
        return `_s_(env, ${stringify(value)})`;
    }
    else {
        throw new Error("prepareValue: unsupported value type, value = " + value);
    }
};

const body = extractConstEnums(tsCode).map(({ name, values }) => {
    const enumObject = `  auto ${name} = Napi::Object::New(env);\n`;

    const setProperty = Object.entries(values).map(([key, value]) => {
        return `  ${name}.Set(${prepareKey(value)}, "${key}");\n`;
    }).join("");

    const setPropertyString = Object.entries(values).map(([key, value]) => {
        return `  ${name}.Set("${key}", ${prepareValue(value)});\n`;
    }).join("");

    const exportsString = `  exports.Set("${name}", ${name});\n`;

    return enumObject + setProperty + setPropertyString + exportsString;
}).join("\n");

const suffix = "}\n";

const result = comment + prefix + body + suffix;

fs.writeFileSync(constEnumApiCppPath, result, "utf8");
